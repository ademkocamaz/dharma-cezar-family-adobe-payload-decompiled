from timeit import default_timer as timer
from binascii import b2a_hex,hexlify


#- First half of the code covers AES schedule calculation. Memory dump processing, line 150 onwards. 

#- AES key schedule calculation taken from: https://www.alexrhodes.io/blog/post/30/
class AesKeySchedule:
    #AES S-box
    s_box = [
        [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
        [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
        [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
        [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
        [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
        [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
        [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
        [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
        [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
        [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
        [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
        [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
        [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
        [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
        [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
        [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]
    ]

    #AES Inverse S-box
    inv_s_box = [
        [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb],
        [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb],
        [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e],
        [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25],
        [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92],
        [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84],
        [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06],
        [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b],
        [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73],
        [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e],
        [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b],
        [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4],
        [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f],
        [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef],
        [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61],
        [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]
    ]

    # Calculate the Round Constants
    #0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
    r_con = [None] * 10
    r_con[0] = 1
    for x in range(1,10):
        if(r_con[x-1] >= 0x80):
            #If the result > 0x80, reduce by the AES irreducible polynomial
            r_con[x] = (2 * r_con[x-1] ) ^ 0x11B
        else:
            #otherwise just double it as normal
            r_con[x] = 2 * r_con[x-1]

    #S-box substitution
    def sbox(self,bIn):
        col = bIn & 0xF
        row = (bIn >> 4) & 0xF
        return self.s_box[row][col]

    #Inverse S-box substitution
    def invsbox(self,bIn):
        col = bIn & 0xF
        row = (bIn >> 4) & 0xF
        return inv_s_box[row][col]

    #Split the 256-bit key into 32-bit words
    def splitkey(self,inkey, words):
        shift = 224
        for x in range(8):
            words[x] = (inkey >> shift) & 0xFFFFFFFF
            shift -= 32
        return words

    #Helper function to byte-wise left rotate a 32-bit word
    def l_rotate_word(self,word):
        word = ((word << 8) & 0xFFFFFF00)  | ((word >> 24) & 0xFF)
        return word

    #The AES G function
    def g(self,wIn, rc):
        wIn = self.l_rotate_word(wIn)
        w0 = wIn >> 24 & 0xFF
        w1 = wIn >> 16 & 0xFF
        w2 = wIn >> 8 &  0xFF
        w3 = wIn & 0xFF
        w0 = self.sbox(w0) ^ rc
        w1 = self.sbox(w1)
        w2 = self.sbox(w2)
        w3 = self.sbox(w3)
        ret = w0 << 24 | w1 << 16 | w2 << 8 | w3
        return ret

    #The AES 256 H-function
    def h(self,wIn):
        w0 = self.sbox(wIn >> 24 & 0xFF)
        w1 = self.sbox(wIn >> 16 & 0xFF)
        w2 = self.sbox(wIn >> 8 &  0xFF)
        w3 = self.sbox(wIn & 0xFF)
        ret = w0 << 24 | w1 << 16 | w2 << 8 | w3
        return ret

    #Split the 256-bit key into 32-bit words
    def splitkey(self,inkey, words):
        shift = 224
        for x in range(8):
            words[x] = (inkey >> shift) & 0xFFFFFFFF
            shift -= 32
        return words

    #Expand the 256-bit key into the 15 round keys
    def key_expansion(self,inkey):
        #Split the initial key into words 0-7
        words = [None] * 60
        words = self.splitkey(inkey, words)
        
        #Start calculating the remaining words
        rconIdx = 0
        for x in range(8,60):
            if x % 8 == 0:
                #every 8th word uses the G function
                words[x] = self.g(words[x-1], self.r_con[rconIdx]) ^ words[x-8]
                rconIdx = rconIdx + 1
            elif x % 4 == 0:
                #Every other fourth word uses the H function
                words[x] = self.h(words[x-1]) ^ words[x-8]
            else:
                #Otherwise use a simple XOR
                words[x] = words[x-1] ^ words[x-8]

        #every 4 words forms a subkey
        keyIdx = 0
        keys = [None] * 15
        for x in range(61):
            if x != 0 and (x % 4) == 0:
                #- NOTE: This is changed from original source. 
                keys[keyIdx] = hex((words[x-4] << 96) | (words[x-3] << 64) | (words[x-2] << 32) | words[x-1])[2:].zfill(32)
                keyIdx = keyIdx + 1

        return keys


#=========================
#- Memory dump processing
#=========================
#- Config variables 
filename="test.adobe"
aes_key_size=32
aes_key_schedule_size=240

#- Variables related to file processing
file_offset=0;
total_keys_found = 0;
min_distinct_bytes=10

start_time = timer()

a=AesKeySchedule()

try:
    #- Open the file
    with open(filename, 'rb') as f:

        #- Read till you find data
        while True:
            #- Seek to the new file offset
            f.seek(file_offset)

            #- Read the key schedule number of bytes
            key_sched_buffer=f.read(aes_key_schedule_size)
            
            #- Exit condition 1: If the read buffer is less than 32 bytes:
            if len(key_sched_buffer) < aes_key_schedule_size:
                break
            
            #- Exit condition 2: When there are no more bytes to be read from the file:
            if not key_sched_buffer:
                break
        
            #- Get the distinct bytes in the key schedule
            n=2
            key_sched_list=[key_sched_buffer[i:i+n] for i in range(0, len(key_sched_buffer), n)]
            distinct_bytes=len(set(key_sched_list))

            #- If we have the desired bytes, consider extracting the key and calculating key-schedule
            if distinct_bytes>=min_distinct_bytes:
                #- Get a possible key
                key_sched_hex=hexlify(key_sched_buffer)
                #print(key_sched_hex)
                #- Multiplying by 2 because the two hex digits make a byte.
                temp_key_hex=key_sched_hex[:aes_key_size*2]
                temp_key_int=int(temp_key_hex,base=16)
                #print(temp_key_int)


                #- Compute Key Schedule
                key_sched_calc=''.join(a.key_expansion(temp_key_int))
                #print(key_sched_calc)

                #- Compare the computed key schedule with what you found. 
                hamming_distance= sum(c1 != c2 for c1, c2 in zip(key_sched_hex, key_sched_calc))
                print(hamming_distance)

                #- Another approximation, if we see there is a difference of more than 3 nibbles, then probably not a key.
                if(hamming_distance<4):
                    #- Increment total number of keys found
                    total_keys_found = total_keys_found +1;

                    print("AES key found: ", temp_key_hex)

            #- Increment file offset one byte at a time
            file_offset=file_offset+1

except KeyboardInterrupt:
    print("User cancelled before end of file")

end_time = timer()
print("Total keys found: ", total_keys_found)
print("Time elapsed = ", end_time-start_time)
